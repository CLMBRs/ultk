import random
from collections import defaultdict
from typing import Any, Callable, Iterable

from altk.language.semantics import Meaning, Referent, Universe


class Rule:
    """Basic class for a grammar rule.  Grammar rules in ALTK correspond
    to functions.  One can think of a grammar as generating complex functions from
    more basic ones.

    Attributes:
        lhs: left-hand side of the rule (can be anything)
            conceptually, the output type of a function
        rhs: right-hand side; assumed to be an iterable
            conceptually, a list of types of inputs
        func: a callable, the function to be computed when a node with this rule is executed
        name: name of the function
        weight: a relative weight to assign to this rule
            when added to a grammar, all rules with the same LHS will be weighted together
    """

    def __init__(
        self,
        lhs: Any,
        rhs: Iterable[Any],
        func: Callable = lambda *args: None,
        name: str = "",
        weight: float = 1.0,
    ):
        self.lhs = lhs
        self.rhs = rhs
        self.func = func
        self.name = name
        self.weight = weight

    def is_terminal(self) -> bool:
        """Whether this is a terminal rule.  In our framework, this means that RHS is empty,
        i.e. there are no arguments to the function.
        """
        return len(self.rhs) == 0

    def __str__(self) -> str:
        out_str = f"{str(self.lhs)} -> {self.name}"
        if not self.is_terminal():
            out_str += f"({', '.join(str(typ) for typ in self.rhs)})"
        return out_str


class GrammaticalExpression:
    """A GrammaticalExpression has been built up from a Grammar by applying a sequence of Rules.
    Crucially, it is _callable_, using the functions corresponding to each rule.

    A GrammaticalExpression, when called, takes in a Referent.  Because of this, a Meaning can
    be generated by specifying a Universe (which contains Referents).

    Attributes:
        name: name of the top-most function
        func: the function
        children: child expressions (possibly empty)
    """

    def __init__(self, name: str, func: Callable, children: Iterable):
        self.name = name
        self.func = func
        self.children = children

    def to_meaning(self, universe: Universe) -> Meaning:
        # TODO: this presupposes that the expression has type Referent -> bool.  Should we generalize?
        return Meaning(
            [referent for referent in universe.referents if self(referent)], universe
        )

    def __call__(self, referent: Referent):
        if len(self.children) == 0:
            return self.func(referent)
        return self.func(*(child(referent) for child in self.children))

    def __str__(self):
        out_str = self.name
        if len(self.children) > 0:
            out_str += f"({', '.join(str(child) for child in self.children)})"
        return out_str


class Grammar:
    """At its core, a Grammar is a set of Rules with methods for generating GrammaticalExpressions."""

    def __init__(self, start: Any):
        # _rules: nonterminals -> list of rules
        self._rules = defaultdict(list)
        self._start = start

    def add_rule(self, rule: Rule):
        self._rules[rule.lhs].append(rule)

    def generate(self, lhs: Any = None) -> GrammaticalExpression:
        """Generate an expression from a given lhs."""
        if lhs is None:
            lhs = self._start
        rules = self._rules[lhs]
        the_rule = random.choices(rules, weights=[rule.weight for rule in rules], k=1)[
            0
        ]
        # if the rule is terminal, rhs will be empty, so no recursive calls to generate will be made in this comprehension
        return GrammaticalExpression(
            the_rule.name,
            the_rule.func,
            [self.generate(child_lhs) for child_lhs in the_rule.rhs],
        )

    def get_all_rules(self) -> list[Rule]:
        """Get all rules as a list."""
        rules = []
        for lhs in self._rules:
            rules.extend(self._rules[lhs])
        return rules

    def __str__(self):
        return "Rules:\n" + "\n".join(f"\t{rule}" for rule in self.get_all_rules())
